---
title: "DEF CON Quals 2018 Writeup"
date: 2018-05-20T18:27:16+09:00
draft: false
tags: ["CTF", "Security"]
---

### Intro.
- Recently, I have tried Permanent CTFs, but haven't participated CTF competitions.
- I participated DEF CON Quals 2018 alone.

### Writeup
#### You Already Know(warmup) - 101pt
>Stop overthinking it, you already know the answer here.
>
>You already have the flag.
>
>Seriously, if you can read this, then you have the flag.

I have seen a problem like this on a write-up and I expected this problem so easy because the problem is **warmup**.  
Anyway, I looked HTTP responce using 'Network' Tab on Chrome DevTools and I found the comment-outed Flag.

#### ELF Crumble(warmup) - 102pt
>We prepared this beautiful binary that just printed for you the welcome flag, but it fell on the ground and broke into pieces.
>
>Luckily no instruction was broken, so I am sure you can just glue it back togetherâ€¦
>
>Flag format is non-standard, there are no brackets.


First of all, I extracted the given tgz file.
```bash
$ ll
-rwxr-xr-x@ 1 teppay  staff   7.3K  5  2 05:37 broken
-rw-r--r--@ 1 teppay  staff    79B  5  2 05:42 fragment_1.dat
-rw-r--r--@ 1 teppay  staff    48B  5  2 05:46 fragment_2.dat
-rw-r--r--@ 1 teppay  staff   175B  5  2 05:47 fragment_3.dat
-rw-r--r--@ 1 teppay  staff    42B  5  2 05:48 fragment_4.dat
-rw-r--r--@ 1 teppay  staff   128B  5  2 05:56 fragment_5.dat
-rw-r--r--@ 1 teppay  staff    22B  5  2 05:56 fragment_6.dat
-rw-r--r--@ 1 teppay  staff   283B  5  2 06:00 fragment_7.dat
-rw-r--r--@ 1 teppay  staff    30B  5  2 06:00 fragment_8.dat

$ file *
broken:         ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=4cd47d8a237a3139d1884b3ef52f6ed387c75772, not stripped
fragment_1.dat: data
fragment_2.dat: data
fragment_3.dat: data
fragment_4.dat: data
fragment_5.dat: data
fragment_6.dat: data
fragment_7.dat: data
fragment_8.dat: data
```

Then, the result of `strings` given the `broken` file is following.

```bash 
$ strings broken
[snip]
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
[snip]
```

It showed `X` of 807 Bytes which is apparently suspicious.  
Then, I guessed that when `flagment-n.dat`s are put into the part filled by `X`s, the `broken` will be **executable**.  

Sum of the file size of `flagment-n.dat`s is same as the length of `X`s.So, the guessing is maybe correct.
```bash
$ expr 79 + 48 + 175 + 42 + 128 + 22 + 283 + 30
807
```
Therefore, I guessed that I should put `flagment-n.dat`s into the part filled by `X`s in the right order.

Next, I gave `broken` to `objdump`. It is found that following 5 functions are filled by `X`s.  

- f1
- f2
- f3
- recover_flag
- main

And, the size of these functions are written below.

- f1 316Byte  (0x5ad~0x6e8)
- f2 69Bytes  (0x6e9~0x72d)
- f3 116Bytes (0x72e~0x7a1)
- recover_flag 58Bytes(0x7a2~0x7db)
- main 248Bytes(0x7dc~0x8d3)

Next, I will research `flagment_n.dat`s.  
  
`objdump` can't open the files, but `IDA` can open them.  Using `IDA`, I researched the structure of `flagment_n.dat`s.

##### fragment_1.dat
- end of a function(3Bytes)|a function(69Bytes)|top of a function(5Bytes)

##### fragment_2.dat
- end of a function(11Bytes)|top of a function(26Bytes)

##### fragment_3.dat
- middle of a function(175Bytes)

##### fragment_4.dat
- end of a function(42Bytes)

##### fragment_5.dat
- end of a function(109Bytes)|top of a function(17Bytes)

##### fragment_6.dat
- middle of a function(20Bytes)

##### fragment_7.dat
- middle of function(281Bytes)

##### fragment_8.dat
- top of function(29Bytes)

According to the size of functions and the structures of `flagment_n.dat`s, the correct order of the **flagments** is `{8,7,1,5,6,2,3,4}`

I created a file `piece` gluing these files.

```
$ cat fragment_8.dat fragment_7.dat fragment_1.dat fragment_5.dat fragment_6.dat fragment_2.dat fragment_3.dat fragment_4.dat > piece
```

Although I wanted to use smarter way, I copied and pasted the file to the part filled by `X`s in the `broken` because I didn't know what to do. And I saved the file as `notbroken`

```
$ ./notbroken
```
When the file executed, the Flag was printed.